{"ast":null,"code":"import _defineProperty from \"/home/rhythm/Documents/Pathfinder/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"/home/rhythm/Documents/Pathfinder/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"/home/rhythm/Documents/Pathfinder/src/PathfindingVisualizer/PathFinder.jsx\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { useState, useEffect } from 'react';\nimport Node from './Node/Node';\nimport { dijkstra, getNodesInShortestPathOrder } from '../algorithms/dijkstra';\nimport './PathfindingVisualizer.css'; //Green Node\n\nconst START_NODE_ROW = 5;\nconst START_NODE_COL = 5; //Red Node\n\nconst FINISH_NODE_ROW = 5;\nconst FINISH_NODE_COL = 10;\n\nconst PathFinder = () => {\n  const _useState = useState([[]]),\n        _useState2 = _slicedToArray(_useState, 2),\n        grid = _useState2[0],\n        setGrid = _useState2[1];\n\n  const _useState3 = useState(false),\n        _useState4 = _slicedToArray(_useState3, 2),\n        mouseIsPressed = _useState4[0],\n        setMouseIsPressed = _useState4[1];\n\n  useEffect(() => {\n    const grid = getInitialGrid();\n    setGrid({\n      grid\n    });\n  }, []);\n\n  function handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setMouseIsPressed(true);\n    setGrid(newGrid);\n  }\n\n  function handleMouseEnter(row, col) {\n    if (!mouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  }\n\n  function handleMouseUp() {\n    setMouseIsPressed(false);\n  }\n\n  function animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 20 * i);\n        return;\n      }\n\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className = 'node node-visited';\n      }, 20 * i);\n    }\n  }\n\n  function animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className = 'node node-shortest-path';\n      }, 100 * i);\n    }\n  }\n\n  function visualizeDijkstra() {\n    const grid = this.state.grid;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL]; //Get relevant information\n\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode); //Perform visual animation\n\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  return React.createElement(React.Fragment, null, React.createElement(\"br\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 82\n    },\n    __self: this\n  }), \" \", React.createElement(\"br\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 82\n    },\n    __self: this\n  }), React.createElement(\"button\", {\n    className: \"btn\",\n    onClick: () => visualizeDijkstra(),\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 83\n    },\n    __self: this\n  }, \"Visualize Dijkstra's Algorithm\"), React.createElement(\"div\", {\n    className: \"grid\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 86\n    },\n    __self: this\n  }, grid.map((row, i) => {\n    return React.createElement(\"div\", {\n      key: i,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 89\n      },\n      __self: this\n    }, row.map((node, j) => {\n      const row = node.row,\n            col = node.col,\n            isFinish = node.isFinish,\n            isStart = node.isStart,\n            isWall = node.isWall;\n      return React.createElement(Node, {\n        key: j,\n        col: col,\n        isFinish: isFinish,\n        isStart: isStart,\n        isWall: isWall,\n        mouseIsPressed: mouseIsPressed,\n        onMouseDown: (row, col) => handleMouseDown(row, col),\n        onMouseEnter: (row, col) => handleMouseEnter(row, col),\n        onMouseUp: () => handleMouseUp(),\n        row: row,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 93\n        },\n        __self: this\n      });\n    }));\n  })));\n};\n\nexport default PathFinder;\n\nconst getInitialGrid = () => {\n  const grid = [];\n\n  for (let row = 0; row < 11; row++) {\n    const currentRow = [];\n\n    for (let col = 0; col < 15; col++) {\n      currentRow.push(createNode(col, row));\n    }\n\n    grid.push(currentRow);\n  }\n\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n\n  const newNode = _objectSpread({}, node, {\n    isWall: !node.isWall\n  });\n\n  newGrid[row][col] = newNode;\n  return newGrid;\n};","map":{"version":3,"sources":["/home/rhythm/Documents/Pathfinder/src/PathfindingVisualizer/PathFinder.jsx"],"names":["React","useState","useEffect","Node","dijkstra","getNodesInShortestPathOrder","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathFinder","grid","setGrid","mouseIsPressed","setMouseIsPressed","getInitialGrid","handleMouseDown","row","col","newGrid","getNewGridWithWallToggled","handleMouseEnter","handleMouseUp","animateDijkstra","visitedNodesInOrder","nodesInShortestPathOrder","i","length","setTimeout","animateShortestPath","node","document","getElementById","className","visualizeDijkstra","state","startNode","finishNode","map","j","isFinish","isStart","isWall","currentRow","push","createNode","distance","Infinity","isVisited","previousNode","slice","newNode"],"mappings":"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","sourcesContent":["import React, {useState ,useEffect} from 'react';\nimport Node from './Node/Node';\nimport {dijkstra, getNodesInShortestPathOrder} from '../algorithms/dijkstra';\n\nimport './PathfindingVisualizer.css';\n\n//Green Node\nconst START_NODE_ROW = 5;\nconst START_NODE_COL = 5;\n\n//Red Node\nconst FINISH_NODE_ROW = 5;\nconst FINISH_NODE_COL = 10;\n\n\nconst PathFinder = () => {\n  const [grid, setGrid] = useState([[]]);\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  \n  useEffect(() => {\n    const grid = getInitialGrid();\n    setGrid({grid});\n  }, []);\n\n  function handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setMouseIsPressed(true);\n    setGrid(newGrid);\n  }\n\n  function handleMouseEnter(row, col) {\n    if (!mouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  }\n\n  function handleMouseUp() {\n    setMouseIsPressed(false);\n  }\n  \n  function animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 20 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited';\n      }, 20 * i);\n    }\n  }\n\n  function animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-shortest-path';\n      }, 100 * i);\n    }\n  }\n\n  function visualizeDijkstra() {\n    const {grid} = this.state;\n\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n\n    //Get relevant information\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n\n    //Perform visual animation\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n    return (\n        <>\n          <br /> <br />\n          <button className='btn' onClick={() => visualizeDijkstra()}>\n            Visualize Dijkstra's Algorithm\n          </button>\n          <div className=\"grid\">\n            {grid.map((row, i) => {\n              return (\n                <div key={i}>\n                  {row.map((node, j) => {\n                    const {row, col, isFinish, isStart, isWall} = node;\n                    return (\n                      <Node\n                        key={j}\n                        col={col}\n                        isFinish={isFinish}\n                        isStart={isStart}\n                        isWall={isWall}\n                        mouseIsPressed={mouseIsPressed}\n                        onMouseDown={(row, col) => handleMouseDown(row, col)}\n                        onMouseEnter={(row, col) =>\n                          handleMouseEnter(row, col)\n                        }\n                        onMouseUp={() => handleMouseUp()}\n                        row={row}>\n                        </Node>\n                    );\n                  })}\n                </div>\n              );\n            })}\n          </div>\n        </>\n      );\n}\n\nexport default PathFinder;\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 11; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 15; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n"]},"metadata":{},"sourceType":"module"}