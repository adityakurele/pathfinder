{"ast":null,"code":"import _defineProperty from \"/home/rhythm/Documents/Pathfinder/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"/home/rhythm/Documents/Pathfinder/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"/home/rhythm/Documents/Pathfinder/src/PathfindingVisualizer/PathFinder.jsx\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { useState, useEffect } from 'react';\nimport Node from './Node/Node';\nimport { dijkstra, getNodesInShortestPathOrder } from '../algorithms/dijkstra';\nimport './PathfindingVisualizer.css'; //Green Node\n\nconst START_NODE_ROW = 5;\nconst START_NODE_COL = 5; //Red Node\n\nconst FINISH_NODE_ROW = 5;\nconst FINISH_NODE_COL = 10;\n\nconst PathFinder = () => {\n  const _useState = useState([]),\n        _useState2 = _slicedToArray(_useState, 2),\n        grid = _useState2[0],\n        setGrid = _useState2[1];\n\n  const _useState3 = useState(false),\n        _useState4 = _slicedToArray(_useState3, 2),\n        mouseIsPressed = _useState4[0],\n        setMouseIsPressed = _useState4[1];\n\n  const getInitialGrid = () => {\n    const grid = [];\n\n    for (let row = 0; row < 11; row++) {\n      const currentRow = [];\n\n      for (let col = 0; col < 15; col++) {\n        currentRow.push(createNode(col, row));\n      }\n\n      grid.push(currentRow);\n    }\n\n    console.log(grid);\n    return grid;\n  };\n\n  const createNode = (col, row) => {\n    return {\n      col,\n      row,\n      isStart: row === START_NODE_ROW && col === START_NODE_COL,\n      isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n      distance: Infinity,\n      isVisited: false,\n      isWall: false,\n      previousNode: null\n    };\n  };\n\n  const getNewGridWithWallToggled = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n\n    const newNode = _objectSpread({}, node, {\n      isWall: !node.isWall\n    });\n\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n\n  useEffect(() => {\n    const grid = getInitialGrid();\n    setGrid(grid);\n  }, []);\n\n  function handleClick(row, col) {\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  }\n\n  function animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 20 * i);\n        return;\n      }\n\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className = 'node node-visited';\n      }, 20 * i);\n    }\n  }\n\n  function animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className = 'node node-shortest-path';\n      }, 100 * i);\n    }\n  }\n\n  function visualizeDijkstra() {\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL]; //Get relevant information\n\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode); //Perform visual animation\n\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  return React.createElement(React.Fragment, null, React.createElement(\"br\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 108\n    },\n    __self: this\n  }), \" \", React.createElement(\"br\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 108\n    },\n    __self: this\n  }), React.createElement(\"button\", {\n    className: \"btn\",\n    onClick: () => visualizeDijkstra(),\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 109\n    },\n    __self: this\n  }, \"Visualize Dijkstra's Algorithm\"), React.createElement(\"div\", {\n    className: \"grid\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 112\n    },\n    __self: this\n  }, grid.map((row, i) => {\n    return React.createElement(\"div\", {\n      key: i,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 115\n      },\n      __self: this\n    }, row.map((node, j) => {\n      const row = node.row,\n            col = node.col,\n            isFinish = node.isFinish,\n            isStart = node.isStart,\n            isWall = node.isWall;\n      return React.createElement(Node, {\n        key: j,\n        col: col,\n        isFinish: isFinish,\n        isStart: isStart,\n        isWall: isWall,\n        mouseIsPressed: mouseIsPressed,\n        onMouseClick: () => {\n          handleClick(row, col);\n        },\n        row: row,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 119\n        },\n        __self: this\n      });\n    }));\n  })));\n};\n\nexport default PathFinder;","map":{"version":3,"sources":["/home/rhythm/Documents/Pathfinder/src/PathfindingVisualizer/PathFinder.jsx"],"names":["React","useState","useEffect","Node","dijkstra","getNodesInShortestPathOrder","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathFinder","grid","setGrid","mouseIsPressed","setMouseIsPressed","getInitialGrid","row","currentRow","col","push","createNode","console","log","isStart","isFinish","distance","Infinity","isVisited","isWall","previousNode","getNewGridWithWallToggled","newGrid","slice","node","newNode","handleClick","animateDijkstra","visitedNodesInOrder","nodesInShortestPathOrder","i","length","setTimeout","animateShortestPath","document","getElementById","className","visualizeDijkstra","startNode","finishNode","map","j"],"mappings":"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","sourcesContent":["import React, {useState ,useEffect} from 'react';\nimport Node from './Node/Node';\nimport {dijkstra, getNodesInShortestPathOrder} from '../algorithms/dijkstra';\n\nimport './PathfindingVisualizer.css';\n\n//Green Node\nconst START_NODE_ROW = 5;\nconst START_NODE_COL = 5;\n\n//Red Node\nconst FINISH_NODE_ROW = 5;\nconst FINISH_NODE_COL = 10;\n\n\nconst PathFinder = () => {\n  const [grid, setGrid] = useState([]);\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n\n  const getInitialGrid = () => {\n    const grid = [];\n    for (let row = 0; row < 11; row++) {\n      const currentRow = [];\n      for (let col = 0; col < 15; col++) {\n        currentRow.push(createNode(col, row));\n      }\n      grid.push(currentRow);\n    }\n    console.log(grid);\n    return grid;\n  };\n  \n  const createNode = (col, row) => {\n    return {\n      col,\n      row,\n      isStart: row === START_NODE_ROW && col === START_NODE_COL,\n      isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n      distance: Infinity,\n      isVisited: false,\n      isWall: false,\n      previousNode: null,\n    };\n  };\n  \n  const getNewGridWithWallToggled = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isWall: !node.isWall,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n  \n  \n  useEffect(() => {\n    const grid = getInitialGrid();\n    setGrid(grid);\n  }, []);\n\n  \n  function handleClick(row,col){\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  }\n\n  function animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 20 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited';\n      }, 20 * i);\n    }\n  }\n\n  function animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-shortest-path';\n      }, 100 * i);\n    }\n  }\n\n  function visualizeDijkstra() {\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n\n    //Get relevant information\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n\n    //Perform visual animation\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n    return (\n        <>\n          <br /> <br />\n          <button className='btn' onClick={() => visualizeDijkstra()}>\n            Visualize Dijkstra's Algorithm\n          </button>\n          <div className=\"grid\">\n            {grid.map((row, i) => {\n              return (\n                <div key={i}>\n                  {row.map((node, j) => {\n                    const {row, col, isFinish, isStart, isWall} = node;\n                    return (\n                      <Node\n                        key={j}\n                        col={col}\n                        isFinish={isFinish}\n                        isStart={isStart}\n                        isWall={isWall}\n                        mouseIsPressed={mouseIsPressed}\n                        onMouseClick={()=>{handleClick(row,col)}}\n                        row={row}>\n                        </Node>\n                    );\n                  })}\n                </div>\n              );\n            })}\n          </div>\n        </>\n      );\n}\n\nexport default PathFinder;"]},"metadata":{},"sourceType":"module"}