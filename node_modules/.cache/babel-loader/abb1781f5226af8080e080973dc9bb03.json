{"ast":null,"code":"import _defineProperty from \"/home/rhythm/Documents/Pathfinder/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"/home/rhythm/Documents/Pathfinder/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"/home/rhythm/Documents/Pathfinder/src/PathfindingVisualizer/PathFinder.jsx\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { useState, useEffect } from 'react';\nimport Node from './Node/Node';\nimport { dijkstra, getNodesInShortestPathOrder } from '../algorithms/dijkstra';\nimport './PathfindingVisualizer.css'; //Green Node => (0,0)\n\nconst START_NODE_ROW = 0;\nconst START_NODE_COL = 0; //Red Node => (n-1, n-1)\n\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 14;\n\nconst PathFinder = () => {\n  //Maintain grid state\n  const _useState = useState([]),\n        _useState2 = _slicedToArray(_useState, 2),\n        grid = _useState2[0],\n        setGrid = _useState2[1]; //Setup initial state of the grid\n\n\n  const getInitialGrid = () => {\n    const grid = [];\n\n    for (let row = 0; row < 11; row++) {\n      const currentRow = [];\n\n      for (let col = 0; col < 15; col++) {\n        currentRow.push(createNode(col, row));\n      }\n\n      grid.push(currentRow);\n    }\n\n    return grid;\n  }; // Utility function for getInitialGrid, to initialize a single node\n\n\n  const createNode = (col, row) => {\n    return {\n      col,\n      row,\n      isStart: row === START_NODE_ROW && col === START_NODE_COL,\n      isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n      distance: Infinity,\n      isVisited: false,\n      isWall: false,\n      previousNode: null\n    };\n  }; //Toggle behavior of a node to act as a wall or not act as a wall \n\n\n  const getNewGridWithWallToggled = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n\n    const newNode = _objectSpread({}, node, {\n      isWall: !node.isWall\n    });\n\n    newGrid[row][col] = newNode;\n    return newGrid;\n  }; //Set grid when component mounts\n\n\n  useEffect(() => {\n    const grid = getInitialGrid();\n    setGrid(grid);\n  }, []); //Handle wall creation\n\n  function handleClick(row, col) {\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  } // First animation function\n\n\n  function animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 20 * i);\n        return;\n      }\n\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className = 'node node-visited';\n      }, 30 * i);\n    }\n  } //Second animation function\n\n\n  function animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(\"node-\".concat(node.row, \"-\").concat(node.col)).className = 'node node-shortest-path';\n      }, 100 * i);\n    }\n  } //Do this when the button visualize is clicked\n\n\n  function visualizeDijkstra() {\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL]; //Get relevant information\n\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode); //Perform visual animation\n\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  } //Grid component\n\n\n  return React.createElement(React.Fragment, null, React.createElement(\"br\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 113\n    },\n    __self: this\n  }), \" \", React.createElement(\"br\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 113\n    },\n    __self: this\n  }), React.createElement(\"button\", {\n    className: \"btn\",\n    onClick: () => visualizeDijkstra(),\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 114\n    },\n    __self: this\n  }, \"Visualize Dijkstra's Algorithm\"), React.createElement(\"div\", {\n    className: \"grid\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 117\n    },\n    __self: this\n  }, grid.map((row, i) => {\n    return React.createElement(\"div\", {\n      key: i,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 120\n      },\n      __self: this\n    }, row.map((node, j) => {\n      const row = node.row,\n            col = node.col,\n            isFinish = node.isFinish,\n            isStart = node.isStart,\n            isWall = node.isWall;\n      return React.createElement(Node, {\n        key: j,\n        col: col,\n        isFinish: isFinish,\n        isStart: isStart,\n        isWall: isWall,\n        onMouseClick: () => {\n          handleClick(row, col);\n        },\n        row: row,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 124\n        },\n        __self: this\n      });\n    }));\n  })));\n};\n\nexport default PathFinder;","map":{"version":3,"sources":["/home/rhythm/Documents/Pathfinder/src/PathfindingVisualizer/PathFinder.jsx"],"names":["React","useState","useEffect","Node","dijkstra","getNodesInShortestPathOrder","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathFinder","grid","setGrid","getInitialGrid","row","currentRow","col","push","createNode","isStart","isFinish","distance","Infinity","isVisited","isWall","previousNode","getNewGridWithWallToggled","newGrid","slice","node","newNode","handleClick","animateDijkstra","visitedNodesInOrder","nodesInShortestPathOrder","i","length","setTimeout","animateShortestPath","document","getElementById","className","visualizeDijkstra","startNode","finishNode","map","j"],"mappings":"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","sourcesContent":["import React, {useState ,useEffect} from 'react';\nimport Node from './Node/Node';\nimport {dijkstra, getNodesInShortestPathOrder} from '../algorithms/dijkstra';\n\nimport './PathfindingVisualizer.css';\n\n//Green Node => (0,0)\nconst START_NODE_ROW = 0;\nconst START_NODE_COL = 0\n\n//Red Node => (n-1, n-1)\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 14;\n\n\nconst PathFinder = () => {\n  //Maintain grid state\n  const [grid, setGrid] = useState([]);\n\n  //Setup initial state of the grid\n  const getInitialGrid = () => {\n    const grid = [];\n    for (let row = 0; row < 11; row++) {\n      const currentRow = [];\n      for (let col = 0; col < 15; col++) {\n        currentRow.push(createNode(col, row));\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  };\n  \n  // Utility function for getInitialGrid, to initialize a single node\n  const createNode = (col, row) => {\n    return {\n      col,\n      row,\n      isStart: row === START_NODE_ROW && col === START_NODE_COL,\n      isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n      distance: Infinity,\n      isVisited: false,\n      isWall: false,\n      previousNode: null,\n    };\n  };\n  \n  //Toggle behavior of a node to act as a wall or not act as a wall \n  const getNewGridWithWallToggled = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isWall: !node.isWall,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n  \n  //Set grid when component mounts\n  useEffect(() => {\n    const grid = getInitialGrid();\n    setGrid(grid);\n  }, []);\n\n  //Handle wall creation\n  function handleClick(row,col){\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  }\n\n  // First animation function\n  function animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 20 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className ='node node-visited';\n      }, 30 * i);\n    }\n  }\n\n  //Second animation function\n  function animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-shortest-path';\n      }, 100 * i);\n    }\n  }\n\n  //Do this when the button visualize is clicked\n  function visualizeDijkstra() {\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n\n    //Get relevant information\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n\n    //Perform visual animation\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n  //Grid component\n    return (\n        <>\n          <br /> <br />\n          <button className='btn' onClick={() => visualizeDijkstra()}>\n            Visualize Dijkstra's Algorithm\n          </button>\n          <div className=\"grid\">\n            {grid.map((row, i) => {\n              return (\n                <div key={i}>\n                  {row.map((node, j) => {\n                    const {row, col, isFinish, isStart, isWall} = node;\n                    return (\n                      <Node\n                        key={j}\n                        col={col}\n                        isFinish={isFinish}\n                        isStart={isStart}\n                        isWall={isWall}\n                        onMouseClick={()=>{handleClick(row,col)}}\n                        row={row}>\n                        </Node>\n                    );\n                  })}\n                </div>\n              );\n            })}\n          </div>\n        </>\n      );\n}\n\nexport default PathFinder;"]},"metadata":{},"sourceType":"module"}